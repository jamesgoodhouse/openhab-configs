import java.util.List
import java.util.Map

val List<String> homeRegions = newArrayList("ESP32-Beacon", "Keychain")
val Map<String, String> regionToItemMap = newHashMap(
  "ESP32-Beacon" -> "JamesPhone_Owntracks_Beacon_Kitchen"
)
val Map<String, String> beaconStates = newHashMap(
  "JamesPhone_Owntracks_Beacon_Kitchen" -> "OFF"
)

rule "Owntracks Raw JSON Changed"
when
  Item JamesPhone_Owntracks_RawJSON changed
then
  val String json = (JamesPhone_Owntracks_RawJSON.state as StringType).toString
  val String type = transform("JSONPATH", "$._type", json)

  if (type == "location") {
    var isHome = "OFF"
    val List<String> keys = transform("JSONPATH", "$.keys()", json).replaceAll("\\[", "").replaceAll("\\]", "").split(", ")
    val String tst = transform("JSONPATH", "$.tst", json)

    if (keys.contains("inregions")) {
      val String regions = transform("JSONPATH", "$.inregions", json)
      JamesPhone_Owntracks_Regions.postUpdate(regions)

      val Number numRegions = Integer::parseInt(transform("JSONPATH", "$.inregions.length()", json))
      logDebug("owntracks", "Number of Regions: {}", numRegions)

      var i = 0
      var String region = ""

      while (i < numRegions) {
        region = transform("JSONPATH", "$.inregions.[" + i + "]", json)

        if (homeRegions.contains(region)) {
          isHome = "ON"
        }

        // set item state for region to ON for known regions
        if (regionToItemMap.containsKey(region)) {
          val regionItemName = regionToItemMap.get(region)
          beaconStates.put(regionItemName, "ON")
        }

        i++
      }

      beaconStates.forEach[item, state |
        logInfo("owntracks", "setting item {} to {}", item, state)
        postUpdate(item, state)
      ]
    }

    JamesPhone_Owntracks_LastSeen.postUpdate(new DateTimeType(tst))
    JamesPhone_Owntracks_InHomeRegion.postUpdate(isHome)
  } else if (type == "lwt") {
    logInfo("owntracks", "Owntracks lost connection to MQTT broker")
    JamesPhone_Owntracks_InHomeRegion.postUpdate(OFF)
  }
end
